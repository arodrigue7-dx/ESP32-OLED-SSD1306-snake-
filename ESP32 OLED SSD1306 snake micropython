from machine import Pin, I2C
import ssd1306
import utime
import urandom as random

# ESP32 Pin assignment 
i2c = I2C(0, scl=Pin(22), sda=Pin(21))

oled_width = 128
oled_height = 64
oled = ssd1306.SSD1306_I2C(oled_width, oled_height, i2c)

buttonPins = [Pin(17), Pin(4), Pin(5), Pin(16)]  # LEFT, UP, RIGHT, DOWN

class State:
    START = 0
    RUNNING = 1
    GAMEOVER = 2

class Direction:
    LEFT = 0
    UP = 1
    RIGHT = 2
    DOWN = 3

gameState = State.START
snake = [[0, 0]] * 165
snake_length = 0
dir = Direction.RIGHT
newDir = Direction.RIGHT
fruit = [0, 0]

def setupGame():
    global gameState, dir, newDir, snake_length, oled
    gameState = State.START
    dir = Direction.RIGHT
    newDir = Direction.RIGHT
    resetSnake()
    generateFruit()
    oled.fill(0)
    drawMap()
    drawScore()
    drawPressToStart()
    oled.show()


def resetSnake():
    global snake_length
    snake_length = 5
    for i in range(snake_length):
        snake[i] = [10 - i, 10]

moveTime = 0

def loop():
    global gameState, moveTime

    if gameState == State.START:
        if buttonPress():
            gameState = State.RUNNING

    elif gameState == State.RUNNING:
        moveTime += 1
        readDirection()
        if moveTime >= 30:
            moveSnake()
            oled.fill(0)
            drawMap()
            drawScore()
            oled.show()
            checkFruit()
            moveTime = 0

    elif gameState == State.GAMEOVER:
        if buttonPress():
            utime.sleep_ms(500)
            setupGame()
            gameState = State.START

    utime.sleep_ms(10)

def buttonPress():
    for i in range(4):
        buttonPin = buttonPins[i]
        if buttonPin.value() == 0:
            return True
    return False

def readDirection():
    global newDir, dir
    for i in range(4):
        buttonPin = buttonPins[i]
        if buttonPin.value() == 0 and i != (dir + 2) % 4:
            newDir = i
            dir = newDir  # Burada dir değişkenini güncelledik
            return

def moveSnake():
    global dir, newDir, moveTime, snake_length

    x, y = snake[0]

    if dir == Direction.LEFT:
        x -= 1
    elif dir == Direction.UP:
        y -= 1
    elif dir == Direction.RIGHT:
        x += 1
    elif dir == Direction.DOWN:
        y += 1

    if collisionCheck(x, y):
        gameState = State.GAMEOVER
        drawGameover()
        utime.sleep_ms(1000)
        return

    for i in range(snake_length - 1, 0, -1):
        snake[i] = snake[i - 1]

    snake[0] = [x, y]

def checkFruit():
    global snake_length, fruit

    if fruit == snake[0]:
        if snake_length + 1 <= 165:
            snake_length += 1
        generateFruit()

def generateFruit():
    global fruit, snake_length

    while True:
        fruit = [random.randint(0, 20), random.randint(0, 20)]

        for i in range(snake_length):
            if fruit == snake[i]:
                continue

        break

def collisionCheck(x, y):
    global snake, snake_length

    for i in range(1, snake_length):
        if x == snake[i][0] and y == snake[i][1]:
            return True

    if x < 0 or y < 0 or x >= 20 or y >= 20:
        return True

    return False

def drawMap():
    global snake, snake_length, fruit

    offsetMapX = oled_width - 3 * 20 - 2
    offsetMapY = 2

    oled.rect(fruit[0] * 3 + offsetMapX, fruit[1] * 3 + offsetMapY, 3, 3, 1)

    oled.rect(offsetMapX - 2, 0, 3 * 20 + 4, 3 * 20 + 4, 1)

    for i in range(snake_length):
        oled.fill_rect(snake[i][0] * 3 + offsetMapX, snake[i][1] * 3 + offsetMapY, 3, 3, 1)

def drawScore():
    global snake_length
    oled.text("Score: {}".format(snake_length - 5), 2, 2)

def drawPressToStart():
    oled.text("Press a button to start the game!", 2, 20)

def drawGameover():
    oled.text("GAMEOVER", 2, 50)
